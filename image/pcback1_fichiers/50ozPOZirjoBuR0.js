window.aui.amd_define("@amzn/flow-metrics-web-lib-latency",function(){"use strict";function N(e,n){return`${e}+${n}`}class b extends Error{constructor(n){super(n),this.name="MetricsRuleError"}}var m=(e=>(e.aboveTheFold="aboveTheFold",e.functional="functional",e.firstContentfulPaint="firstContentfulPaint",e))(m||{}),h=(e=>(e.EXISTS="EXISTS",e.MAX="MAX",e.MIN="MIN",e.SUM="SUM",e.UNKNOWN="UNKNOWN",e))(h||{});const R={aboveTheFold:"af",functional:"fn",firstContentfulPaint:"fcp_ovr"};function T(e,n,a="ERROR",l){let i;n instanceof Error?i=n:i={message:n?String(n):""},i.message.length===0?i.message=e:i.message=`${e} - ${i.message}`;const r={logLevel:a,attribution:"FlowMetricsWebLib",message:""};typeof window<"u"&&window.ueLogError?window.ueLogError(i,r):console.error(`CSM ueLogError not found: ${i} , ${JSON.stringify(r)}`)}const p=(e,n,a)=>{T(e,n,"ERROR")},S=(e,n)=>{typeof window<"u"&&window.uet?window.uet(R[e],void 0,void 0,n):console.error("CSM uet not found!")},k=()=>{if(typeof window>"u"){console.error("window is not initialized");return}if(window.ue===void 0){console.error("CSM ue not found");return}if(window.ue.isl){if(window.uex===void 0){console.error("CSM uex not found");return}window.uex("at")}};var C=(e=>(e.NodeEventDataNotFound="M003",e.MetricsCalculatorError="M004",e.MetricInstructionParsingError="M005",e))(C||{});function O(e,n){const a=function(o){const r=N(o.id,o.event);return e.get(r)},l=function(o){const r=(()=>{switch(o.operator){case h.MAX:return Math.max;case h.MIN:return Math.min;case h.SUM:return(f,u)=>f+u;default:throw new b(`Calculation error: Unknown operator : ${o.operator}!`)}})();return o.metricRules.map(f=>{const{combination:u,nodeEvent:w}=f;if(u)return l(u);if(w)return a(w);throw new b(`Calculation error: Unknown rule type : ${Object.keys(f)}!`)}).reduce((f,u)=>r(f,u))};return Object.freeze({calculateMetrics:function(){const o={};try{n.forEach(r=>{const{metricName:f,metricRule:{combination:u,nodeEvent:w}}=r;let M=0;if(u)M=l(u);else if(w)M=a(w);else throw new b(`Calculation error: Unknown rule type : ${Object.keys(r.metricRule)}!`);o[f]=M})}catch(r){p(C.MetricsCalculatorError,r)}return o}})}function $(e,n){const l=O(e,n).calculateMetrics(),i=l[m.aboveTheFold],o=l[m.functional],r=l[m.firstContentfulPaint];i&&o?(S(m.aboveTheFold,i),S(m.functional,o)):console.error("sendExperienceRenderMetrics: missing aboveTheFold or functional timestamp!"),r?S(m.firstContentfulPaint,r):console.error("sendExperienceRenderMetrics: using the CSM default fcp!"),k()}function U(){let e=[];const n=new Set,a=new Map,l=new Map,i=new Map,o=new Map,r=function(t,s,c){console.log("registerInstrumentationEvents",JSON.stringify({nodeId:t,payload:s,timestamp:c})),c=c||Date.now();for(const[d,v]of Object.entries(s)){const g=N(t,d);if(o.set(g,{lastTimestamp:c,count:v.length,instrumentationEvents:new Set}),v.length===0)console.log("No need to record instrumentation events.",g,c),w(g,c);else for(const E of v)l.set(E,g),u(E)}},f=function(t,s){console.log("recordInstrumentationEvent",JSON.stringify({instrumentationId:t,timestampOverride:s})),i.set(t,s||Date.now()),u(t)},u=function(t){const s=i.get(t),c=l.get(t);if(!s||!c)return;const d=o.get(c);if(!d){p(C.NodeEventDataNotFound);return}const{lastTimestamp:v,count:g,instrumentationEvents:E}=d,I=Math.max(v,s);E.add(t),o.set(c,{lastTimestamp:I,count:g,instrumentationEvents:E}),g===E.size&&(console.log("All instrumentation events recorded",c,I),w(c,I))},w=function(t,s){n.has(t)?a.set(t,s):console.error(`The ${t} is not registered!`),L()&&(console.log("All required node events recorded!"),$(a,e))},M=function(t){console.log("updateMetricInstructions",JSON.stringify(t)),e=[...e,...t],A(e)},x=function(t,s){n.add(N(t,s))},y=function(t){const{combination:s,nodeEvent:c}=t;if(s)s.metricRules.forEach(d=>{y(d)});else if(c)x(c.id,c.event);else throw new b(`Unknown rule type : ${Object.keys(t)}!`)},A=function(t){try{t.forEach(s=>{y(s.metricRule)})}catch(s){n.clear(),p(C.MetricInstructionParsingError,s)}},L=function(){return n.size===a.size};return Object.freeze({registerInstrumentationEvents:r,recordInstrumentationEvent:f,updateMetricInstructions:M,flowCardsCallback:function(t,s){console.log("flowCardsCallback",JSON.stringify({slotName:t}));try{if(!window.P){console.error("P object not available");return}window.P.when("A").execute(c=>{const d=c;if(!d){console.error("AUI A object not available");return}const v=`fm:flowCardCallback+${t}`;d.on(v,s),console.log(`Subscribed to flow card event: ${v}`)})}catch(c){console.error("flowCardsCallback: Failed to subscribe to AUI event",c)}},reset:function(){l.clear(),o.clear(),a.clear(),n.clear(),e=[]},get instrumentation2NodeEvent(){return l},get nodeEventsData(){return o},get nodeEvents(){return a},get registerNodeEvents(){return n}})}const F=U();function P(){var o;const e=window==null?void 0:window.fm;if(!e)return;const{flowCardsCallback:n,registerInstrumentationEvents:a,recordInstrumentationEvent:l,updateMetricInstructions:i}=F;e.flowCardsCallback=n,e.registerInstrumentationEvents=a,e.recordInstrumentationEvent=l,i(e.i),e._calls&&(e._calls.registerInstrumentationEvents.forEach(r=>a(...r)),e._calls.recordInstrumentationEvent.forEach(r=>l(...r)),(o=e._calls.flowCardsCallback)==null||o.forEach(r=>n(...r))),delete e._calls}P()});
